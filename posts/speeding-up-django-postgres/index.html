<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Speeding up Django / PostgreSQL
        
    </title><meta content="Speeding up Django / PostgreSQL" property=og:title><meta content="Tips to improve performance with Django/PostgreSQL" property=og:description><meta content="Tips to improve performance with Django/PostgreSQL" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://ashang.github.io/zz/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://ashang.github.io/zz/atom.xml rel=alternate title=atbb type=application/atom+xml><link href=https://ashang.github.io/zz/theme/light.css rel=stylesheet><link href=https://ashang.github.io/zz/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://ashang.github.io/zz/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://ashang.github.io/zz/>atbb</a><div class=socials><a class=social href=https://github.com/ashang/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=$BASE_URL/search/ style=margin-left:.7em>Search</a><a href=/notes style=margin-left:.7em>/notes</a><a href=/posts style=margin-left:.7em>/posts</a><a href=/gallery style=margin-left:.7em>/gallery</a><a href=/tags style=margin-left:.7em>/tags</a><a href=/projects style=margin-left:.7em>/projects</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://ashang.github.io/zz/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Speeding up Django / PostgreSQL<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2014-08-20</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#background>Background</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#speeding-up-django-queries>Speeding up Django queries</a> <ul><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#only>Only</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#update-fields>Update fields</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#bulk-create>Bulk create</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#mass-update>Mass update</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#indices>Indices</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#transactions>Transactions</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#bonus-select-related-and-prefetch-related>Bonus: select_related and prefetch_related</a></ul><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#postgres-speed-improvement>Postgres speed improvement</a><li><a href=https://ashang.github.io/zz/posts/speeding-up-django-postgres/#conclusion>Conclusion</a></ul><section class=body><h2 id=background>Background</h2><p>At my current contract, we process hundreds of thousand of articles a day and those are saved in some different models as we go along the pipeline. The stack for that application is Django (1.6) + PostgreSQL (9.3) + <a href=http://python-rq.org/>rq</a> (alternative to the classic Celery for the queues). Tasks started to take way too much time and so I started looking into. This is not going to mention caching but things should obviously be cached if it is possible in your project.<h2 id=speeding-up-django-queries>Speeding up Django queries</h2><p>The PostgreSQL database being on his own server, I assumed it was properly configured (spoiler: it wasn't) and thus started the investigation in the django project. The models in that case are news articles, so it contains the text of the article (and it can get pretty big) as well as lots of metadata about it. All in all, one of these objects can get pretty big (relatively speaking, keep in mind there are tens of millions of them) so getting/saving them can take some time.<h3 id=only>Only</h3><p>Most of the time you do not need to get the whole object, you might want to only get one or two fields, very simple thing to do in SQL and in Django as well thanks to .only():<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span style=font-style:italic;color:#5c6773># Equivalent to SELECT id FROM myapp_article;
</span><span>Article</span><span style=color:#f29668>.</span><span>objects</span><span style=color:#f29668>.</span><span style=color:#ffb454>all</span><span>()</span><span style=color:#f29668>.</span><span style=color:#ffb454>only</span><span>(</span><span style=color:#c2d94c>'id'</span><span>)
</span><span style=font-style:italic;color:#5c6773># Note that for .get(), only needs to be placed before .get() as only() is a method
</span><span style=font-style:italic;color:#5c6773># of Queryset and .get() returns a model
</span><span>Article</span><span style=color:#f29668>.</span><span>objects</span><span style=color:#f29668>.</span><span style=color:#ffb454>only</span><span>(</span><span style=color:#c2d94c>'id'</span><span>)</span><span style=color:#f29668>.</span><span style=color:#ffb454>get</span><span>(</span><span style=color:#f29718>id</span><span style=color:#f29668>=</span><span style=color:#f29718>42</span><span>)
</span></code></pre><p>That sped up things in some places, but it was still pretty damn slow.<h3 id=update-fields>Update fields</h3><p>Looking at the slow queries log (more on that in the postgres part below), the issue was very clear: when updating an article on one field, it was re-saving everything ! Django's ORM comes with an easy way to fix that:<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span style=font-style:italic;color:#5c6773># Equivalent to UPDATE myapp_article SET url='http://www.google.com' WHERE id = 42;
</span><span>article </span><span style=color:#f29668>= </span><span>Article</span><span style=color:#f29668>.</span><span>objects</span><span style=color:#f29668>.</span><span style=color:#ffb454>get</span><span>(</span><span style=color:#f29718>id</span><span style=color:#f29668>=</span><span style=color:#f29718>42</span><span>)
</span><span>article</span><span style=color:#f29668>.</span><span>url </span><span style=color:#f29668>= </span><span style=color:#c2d94c>'http://www.google.com'
</span><span style=font-style:italic;color:#5c6773># article.save() -> naive way, will update every field
</span><span>article</span><span style=color:#f29668>.</span><span style=color:#ffb454>save</span><span>(</span><span style=color:#f29718>update_fields</span><span style=color:#f29668>=</span><span>[</span><span style=color:#c2d94c>'url'</span><span>]) </span><span style=font-style:italic;color:#5c6773># correct way
</span></code></pre><h3 id=bulk-create>Bulk create</h3><p>Another thing to try was to bulk insert articles instead of creating them while looping:<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span>to_insert </span><span style=color:#f29668>= </span><span>[]
</span><span style=color:#ff7733>for </span><span>article </span><span style=color:#ff7733>in </span><span>articles:
</span><span>  </span><span style=color:#ff7733>if </span><span>needs_saving:
</span><span>    to_insert</span><span style=color:#f29668>.</span><span style=color:#ffb454>append</span><span>(article)  </span><span style=font-style:italic;color:#5c6773># article is a dict here
</span><span>
</span><span>Article</span><span style=color:#f29668>.</span><span>objects</span><span style=color:#f29668>.</span><span style=color:#ffb454>bulk_create</span><span>([
</span><span>    </span><span style=color:#ffb454>Article</span><span>(</span><span style=color:#f29668>**</span><span>article) </span><span style=color:#ff7733>for </span><span>article </span><span style=color:#ff7733>in </span><span>to_insert
</span><span>])
</span><span>
</span></code></pre><p>There are a few caveats to be aware of when using using bulk_create, those are explained in the <a href=https://docs.djangoproject.com/en/dev/ref/models/querysets/#bulk-create>django doc</a>.<p>That's three problems fixed. Still slow though.<h3 id=mass-update>Mass update</h3><p>In the same spirit of the bulk_create, mass update will also speed up your code quite a bit:<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span>ids_to_update </span><span style=color:#f29668>= </span><span>[]
</span><span style=font-style:italic;color:#5c6773># Code that appends to ids_to_update
</span><span>Article</span><span style=color:#f29668>.</span><span>objects</span><span style=color:#f29668>.</span><span style=color:#ffb454>filter</span><span>(</span><span style=color:#f29718>id__in</span><span style=color:#f29668>=</span><span>ids_to_update)</span><span style=color:#f29668>.</span><span style=color:#ffb454>update</span><span>(</span><span style=color:#f29718>failed</span><span style=color:#f29668>=</span><span style=color:#f29718>True</span><span>)
</span></code></pre><p>This will be much faster than doing one update for each article individually as it will be done in a single SQL 'UPDATE' query.<h3 id=indices>Indices</h3><p>Another one was to add an index on a column that was used to filter but wasn't an index at all:<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span>external_id </span><span style=color:#f29668>= </span><span>models</span><span style=color:#f29668>.</span><span style=color:#ffb454>IntegerField</span><span>(</span><span style=color:#f29718>db_index</span><span style=color:#f29668>=</span><span style=color:#f29718>True</span><span>)
</span><span style=font-style:italic;color:#5c6773># And then run a south or django 1.7+ migration
</span></code></pre><p>Adding an index in postgres is pretty damn fast so do not be worried about the time it could take and sped up those queries significantly (ie they do not appear in the slow queries log).<h3 id=transactions>Transactions</h3><p>The last trick is to wrap a method/bit of code to ensure atomicity. Django provides a method usable both as a decorator and as a context manager allowing to do that:<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span style=font-style:italic;color:#5c6773># As a decorator
</span><span style=color:#bfbab0cc>@</span><span>transaction</span><span style=color:#f29668>.</span><span style=color:#ffb454>atomic
</span><span style=color:#ff7733>def </span><span style=color:#ffb454>do_lots_of_queries</span><span>:
</span><span>  </span><span style=color:#ff7733>pass
</span><span>
</span><span style=font-style:italic;color:#5c6773># As a context manager
</span><span style=color:#ff7733>with </span><span>transaction</span><span style=color:#f29668>.</span><span style=color:#ffb454>atomic</span><span>():
</span><span>  </span><span style=font-style:italic;color:#5c6773># do queries
</span><span>  </span><span style=color:#ff7733>pass
</span></code></pre><p>This prevents from commiting every query and can speed up the piece of code significantly. Use that sparingly though as transactions can have some performance cost, make sure it's actually better before putting everything in transactions.<p>After all these changes, the processing was faster but still super slow. I decided to then look at the DB server but just an additional tip before.<h3 id=bonus-select-related-and-prefetch-related>Bonus: select_related and prefetch_related</h3><p>Another thing I didn't use there (because in my case I didn't need to select related objects) is <a href=https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.select_related>select_related</a> and <a href=https://docs.djangoproject.com/en/dev/ref/models/querysets/#prefetch-related>prefetch_related</a>. Those are used when you need to get associated models you know you will need later in your code and don't want to do a query for each. select_related is used where you have a one-to-many or one-to-one (and do a JOIN in SQL in one query) and prefetch_related for many-to-one and many-to-many (do one query per type of object and join them in python). This can shave a huge amount of queries from your total number of queries: at my last job it went from ~1000 to ~50 just by using those. For example, let's say you have an Article and Author model and you want to display a template with the article content and the author data.<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span style=font-style:italic;color:#5c6773># Let's assume there are 50 articles
</span><span>articles </span><span style=color:#f29668>= </span><span>Article</span><span style=color:#f29668>.</span><span>objects</span><span style=color:#f29668>.</span><span style=color:#ffb454>all</span><span>()</span><span style=color:#f29668>.</span><span style=color:#ffb454>select_related</span><span>(</span><span style=color:#c2d94c>'author'</span><span>)
</span><span>
</span><span>{</span><span style=color:#f29668>% </span><span style=color:#ff7733>for </span><span>article </span><span style=color:#ff7733>in </span><span>articles </span><span style=color:#f29668>%</span><span>}
</span><span>  {{ article }} {{ article</span><span style=color:#f29668>.</span><span>author</span><span style=color:#f29668>.</span><span>name }}  </span><span style=font-style:italic;color:#5c6773># without select_related this will do an additional query per loop
</span><span>{</span><span style=color:#f29668>% </span><span>endfor </span><span style=color:#f29668>%</span><span>}
</span><span>
</span><span style=font-style:italic;color:#5c6773># With select_related:  1 query
</span><span style=font-style:italic;color:#5c6773># Without: 51 queries
</span></code></pre><p>You can easily see from the example how it helps A LOT. To easily spot the places where you can/should use them, install <a href=https://github.com/django-debug-toolbar/django-debug-toolbar>django-debug-toolbar</a> and look at the SQL panels.<h2 id=postgres-speed-improvement>Postgres speed improvement</h2><p>The first thing I did (and I actually did it before doing most changes I mentioned in the django part) is to activate the slow queries logging. This will make postgres log everything that takes can more than X seconds (where you define X). All the changes mentioned below are done in postgresql.conf, located in /etc/postgresql/9.3/main (change 9.3 for your version obviously).<pre class=language-ini data-lang=ini style=background:#0f1419;color:#bfbab0><code class=language-ini data-lang=ini><span style=font-style:italic;color:#5c6773># allows to log in the log directory specified below
</span><span style=color:#f29718>logging_collector </span><span style=color:#f29668>= </span><span style=color:#f29718>on
</span><span style=font-style:italic;color:#5c6773># with that setting, logs will be saved in /var/lib/postgresql/9.3/main/pg_log/
</span><span style=color:#f29718>log_directory </span><span style=color:#f29668>= </span><span style=color:#c2d94c>'pg_log'
</span><span style=font-style:italic;color:#5c6773># Log queries that take more than 1s (I told you it was slow)
</span><span style=color:#f29718>log_min_duration_statement </span><span style=color:#f29668>= </span><span style=color:#f29718>1000
</span></code></pre><p>This allowed me to detect the slow queries caused by the absence of .only() and update_fields.<p>After doing all the fixes in the Django code I was still seing ridiculously slow queries (a good number were taking more than 20s). Now when I added the slow queries logging, I noticed the absence of custom configuration at the bottom of the file. Surely if there's a server dedicated to the DB, postgres will have been tuned to use all the amazing amount of RAM available (I initially thought I had a bug when free -m told me the server had 64go of memory). The tuning looks something like that (see the <a href=https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server>guide</a> to know which values to choose):<pre class=language-ini data-lang=ini style=background:#0f1419;color:#bfbab0><code class=language-ini data-lang=ini><span style=color:#f29718>log_min_duration_statement </span><span style=color:#f29668>= </span><span style=color:#f29718>1000
</span><span style=color:#f29718>max_connections </span><span style=color:#f29668>= </span><span style=color:#f29718>100
</span><span style=color:#f29718>shared_buffers </span><span style=color:#f29668>= </span><span style=color:#f29718>15GB
</span><span style=color:#f29718>effective_cache_size </span><span style=color:#f29668>= </span><span style=color:#f29718>45GB
</span><span style=color:#f29718>work_mem </span><span style=color:#f29668>= </span><span style=color:#f29718>78643kB
</span><span style=color:#f29718>maintenance_work_mem </span><span style=color:#f29668>= </span><span style=color:#f29718>2GB
</span><span style=color:#f29718>checkpoint_segments </span><span style=color:#f29668>= </span><span style=color:#f29718>128
</span><span style=color:#f29718>checkpoint_completion_target </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#f29668>.</span><span style=color:#f29718>9
</span><span style=color:#f29718>wal_buffers </span><span style=color:#f29668>= </span><span style=color:#f29718>16MB
</span><span style=color:#f29718>default_statistics_target </span><span style=color:#f29668>= </span><span style=color:#f29718>500
</span></code></pre><p>This made everything run about 10x faster.<h2 id=conclusion>Conclusion</h2><p>Most of the time, the biggest bottleneck will be the database so do not forget that you are not using SQL and therefore you might make mistakes using an ORM (forgetting the update_fields for example) that you would never do in SQL. The first thing to check would be the postgres config if queries are running slow but don't forget to optimize the django part as well. In this project, some queries will still require tuning through EXPLAIN (probably worth a different article). Including the postgres tuning and the django changes, the code is running 10 and 100x faster than it was before.</section></article></main></div>