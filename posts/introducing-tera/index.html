<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Introducing Tera, a template engine in Rust
        
    </title><meta content="Introducing Tera, a template engine in Rust" property=og:title><meta content="A template engine in Rust inspired by Jinja2/Django" property=og:description><meta content="A template engine in Rust inspired by Jinja2/Django" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://ashang.github.io/zz/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://ashang.github.io/zz/atom.xml rel=alternate title=atbb type=application/atom+xml><link href=https://ashang.github.io/zz/theme/light.css rel=stylesheet><link href=https://ashang.github.io/zz/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://ashang.github.io/zz/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://ashang.github.io/zz/>atbb</a><div class=socials><a class=social href=https://github.com/ashang/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=$BASE_URL/search/ style=margin-left:.7em>Search</a><a href=/notes style=margin-left:.7em>/notes</a><a href=/posts style=margin-left:.7em>/posts</a><a href=/gallery style=margin-left:.7em>/gallery</a><a href=/tags style=margin-left:.7em>/tags</a><a href=/projects style=margin-left:.7em>/projects</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://ashang.github.io/zz/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Introducing Tera, a template engine in Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2016-04-15</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#goals-and-philosophy>Goals and philosophy</a><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#how-it-s-made>How it's made</a> <ul><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#lexer-parser>Lexer/Parser</a><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#context>Context</a><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#rendering>Rendering</a></ul><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#feedback-on-the-dev-aspect>Feedback on the dev aspect</a><li><a href=https://ashang.github.io/zz/posts/introducing-tera/#what-s-next>What's next</a></ul><section class=body><p>in <a href=https://github.com/wearewizards/proppyweb>Proppy</a> to Rust: <a href=https://crates.io/crates/jsonwebtoken>jwt</a>, <a href=https://crates.io/crates/bcrypt>bcrypt</a> (granted that Argon2 seems superior) and a <a href=https://crates.io/crates/dbmigrate>migration tool</a>. While I mostly do SPAs these days and don't write many templates in the backend, I still need one for some occasions. When using Python, I like <a href=http://jinja.pocoo.org/docs/dev/>Jinja2</a> and <a href=https://docs.djangoproject.com/en/1.9/topics/templates/#the-django-template-language>Django templates</a>. Here's how I attempted to port them to Rust and the result is <a href=https://github.com/Keats/tera/>Tera</a>.<h2 id=goals-and-philosophy>Goals and philosophy</h2><p>As mentioned before, the inspiration comes from both Jinja2 and Django templates. As you might know, those two have similar syntax but different philosophies: Django templates are for presentation only and don't allow a lot of logic while Jinja2 has more powerful programming constructs in the templates. I side with Django on this one as complex logic is better put in code than in a template but Django goes a bit too far by even not supporting something like <code>{{ count + 1 }}</code>.<p>So here are some of the features I want:<ul><li>math operations in templates<li>no macros or other complex logic in the template<li>beautiful html output out of the box (ie no need for the <code>{{-</code> tags)<li>simple inheritance<li>simple to use filters<li>able to register new tags easily like the <code>{% url ... %}</code> in Django<li>include partial templates</ul><p>While new tags are definitely logic in the template, that logic would have to be written in Rust and not in a template. That limits reusability but is simpler to understand in the end.<p>Filters should be kept simple and be limited in scope: variable in, modifier function with optional argument and return a string. The easiest to think of would be uppercase, lowercase, capitalize and more importantly time formatting. Here are some examples of how it should look:<pre class=language-jinja data-lang=jinja style=background:#0f1419;color:#bfbab0><code class=language-jinja data-lang=jinja><span>{{ name | uppercase }}
</span><span>{{ birthday | time:</span><span style=color:#c2d94c>"YYYY-MM-dd" </span><span>}}
</span></code></pre><p>Users should be able to add their own filters as well.<p>In terms of error handling, we cannot do anything if a template cannot be parsed so panicking when encountering an error is fine and template compilation should be done at rustc compile time to ensure everything works perfectly (more on that on the README.md). On the API side, using Tera should be trivial:<ul><li>give a glob that will load all the matching files<li>register tag/filter to Tera<li>parse all templates<li>create a context easily (not as simple as a dict obviously though)<li>call a render method that returns a <code>Result</code></ul><p>In code that would like that:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=font-style:italic;color:#5c6773>// setting up
</span><span style=color:#ff7733>let mut</span><span> tera </span><span style=color:#f29668>= </span><span>Tera</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#c2d94c>"./app/**/*.html"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>tera</span><span style=color:#f29668>.</span><span style=color:#f07178>register_tag</span><span>(url_for)</span><span style=color:#bfbab0cc>;
</span><span>tera</span><span style=color:#f29668>.</span><span style=color:#f07178>register_tag</span><span>(retina)</span><span style=color:#bfbab0cc>;
</span><span>tera</span><span style=color:#f29668>.</span><span style=color:#f07178>register_filter</span><span>(number_format)</span><span style=color:#bfbab0cc>;
</span><span>tera</span><span style=color:#f29668>.</span><span style=color:#f07178>parse</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=font-style:italic;color:#5c6773>// rendering
</span><span style=color:#ff7733>let mut</span><span> context </span><span style=color:#f29668>= </span><span>Context</span><span style=color:#f29668>::</span><span>new()</span><span style=color:#bfbab0cc>;
</span><span>context</span><span style=color:#f29668>.</span><span style=color:#f07178>add</span><span>(</span><span style=color:#c2d94c>"user"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>user)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>tera</span><span style=color:#f29668>.</span><span style=color:#f07178>render</span><span>(</span><span style=color:#c2d94c>"user/profile.html"</span><span style=color:#bfbab0cc>,</span><span> context)
</span></code></pre><p>Template compilation should only happen once. This can be achieved by using <a href=https://crates.io/crates/lazy_static>lazy_static</a>.<p>Let's see how it's built now!<h2 id=how-it-s-made>How it's made</h2><p>I actually thought of making a template engine after watching the "Lexical Scanning in Go" video by Rob Pike (<a href="https://www.youtube.com/watch?v=HxaD_trXwRE">youtube link</a>).<h3 id=lexer-parser>Lexer/Parser</h3><p>This talk explains how the lexing in the <a href=https://golang.org/pkg/text/template/>template package in the Go standard library</a> is implemented. I thought it was pretty cool and implemented something similar last summer. For those that don't want to watch the video, here's a quick summary.<p>The lexer can be in a few states: inside a block, text, space, number, identifier, string for Tera currently and there are actions that represents what we do and result in a new state. In short, that means we have a state function that takes the lexer as an argument and returns a state function. While this is easy to do in Go, you cannot do reference the type while declaring it but it's ok to do so for a struct.<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=font-style:italic;color:#5c6773>// working
</span><span style=color:#ff7733>struct </span><span style=color:#59c2ff>StateFn</span><span>(</span><span style=font-style:italic;color:#39bae6>Option</span><span><</span><span style=color:#ff7733>fn</span><span>(</span><span style=color:#f29668>&</span><span style=color:#ff7733>mut</span><span> Lexer) </span><span style=color:#bfbab0cc>-></span><span> StateFn</span><span style=color:#f29668>></span><span>)</span><span style=color:#bfbab0cc>;
</span><span style=font-style:italic;color:#5c6773>// not working
</span><span style=color:#ff7733>type </span><span style=color:#59c2ff>StateFn </span><span style=color:#f29668>= </span><span style=color:#ff7733>fn</span><span>(</span><span style=color:#f29668>&</span><span style=color:#ff7733>mut</span><span> Lexer) </span><span style=color:#bfbab0cc>-> </span><span style=font-style:italic;color:#39bae6>Option</span><span>&LTStateFn></span><span style=color:#bfbab0cc>;
</span></code></pre><p>Thanks for the help on IRC for that one. The lexer just runs the state function until we reach EOF which in our case is represented by returning <code>None</code> as a state function. Here's the whole run method of the lexer:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>pub fn </span><span style=color:#ffb454>run</span><span>(</span><span style=color:#f29668>&</span><span style=color:#ff7733>mut </span><span style=color:#f29718>self</span><span>) {
</span><span>    </span><span style=color:#ff7733>loop </span><span>{
</span><span>        </span><span style=color:#ff7733>let</span><span> StateFn(state_fn) </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>state</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>if</span><span> state_fn</span><span style=color:#f29668>.</span><span style=color:#f07178>is_none</span><span>() {
</span><span>            </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>state </span><span style=color:#f29668>=</span><span> state_fn</span><span style=color:#f29668>.</span><span style=color:#f07178>unwrap</span><span>()(</span><span style=font-style:italic;color:#39bae6>self</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The actions read the next character and know what to do for each kind of character, eg. finding a number in a variable block will return the <code>lex_number</code> state function. The lexer ouput is a vector of tokens that ends with either a EOF or an error.<p>You can read the whole lexer <a href=https://github.com/Keats/tera/blob/fddb8a0b82cba7374bd0552fed1cf831b8943395/src/lexer.rs>on GitHub</a>, it is actually quite simple and readable.<p>The parser is quite simple as well. Since we are either in text, in a variable block or in a tag block, we just handle those cases in a loop and use EOF to break. Each "state" knows how to parse itself so the main logic is actually only:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>pub fn </span><span style=color:#ffb454>parse</span><span>(</span><span style=color:#f29668>&</span><span style=color:#ff7733>mut </span><span style=color:#f29718>self</span><span>) {
</span><span>    </span><span style=color:#ff7733>loop </span><span>{
</span><span>        </span><span style=color:#ff7733>match </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span style=color:#f07178>peek</span><span>()</span><span style=color:#f29668>.</span><span>kind {
</span><span>            TokenType</span><span style=color:#f29668>::</span><span>TagStart </span><span style=color:#f29668>=> </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span style=color:#f07178>parse_tag_block</span><span>()</span><span style=color:#bfbab0cc>,
</span><span>            TokenType</span><span style=color:#f29668>::</span><span>VariableStart </span><span style=color:#f29668>=> </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span style=color:#f07178>parse_variable_block</span><span>()</span><span style=color:#bfbab0cc>,
</span><span>            TokenType</span><span style=color:#f29668>::</span><span>Text </span><span style=color:#f29668>=> </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span style=color:#f07178>parse_text</span><span>()</span><span style=color:#bfbab0cc>,
</span><span>            TokenType</span><span style=color:#f29668>::</span><span>Eof </span><span style=color:#f29668>=> </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>,
</span><span>            </span><span style=color:#f29668>_ => </span><span style=color:#f07178>unreachable!</span><span>()
</span><span>        }</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The trickiest bit was handling precedence in blocks so that something like <code>{{1 / 2 + 3 * 2 + 42}}</code> would parse as expected. This is done by assigning precedence values to each kind of token and looking forward to see if something with higer precedence is coming. I would be surprised if there was not a bug in there.<p>The output of the parser is a classic AST.<h3 id=context>Context</h3><p>Context is where dynamic languages have the upper hand. In python I can just pass a dict <code>{"user": user, "count": 1}</code> to Jinja2 or Django and be done with it. In Rust, it can't be that easy unfortunately. Here's the same context as above for Tera:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let mut</span><span> context </span><span style=color:#f29668>= </span><span>Context</span><span style=color:#f29668>::</span><span>new()</span><span style=color:#bfbab0cc>;
</span><span>context</span><span style=color:#f29668>.</span><span style=color:#f07178>add</span><span>(</span><span style=color:#c2d94c>"user"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>user)</span><span style=color:#bfbab0cc>;
</span><span>context</span><span style=color:#f29668>.</span><span style=color:#f07178>add</span><span>(</span><span style=color:#c2d94c>"count"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span></code></pre><p>To make that possible, Tera uses <a href=https://github.com/serde-rs/serde>serde</a> which means that in the example above, the <code>user</code> variable would have to implement the <code>Serialize</code> trait. This makes Tera annoying to use on non-nightly Rust as compiler plugins are not stable yet. Serde is the future for serialization in Rust so might as well embrace it.<h3 id=rendering>Rendering</h3><p>In the rendering phase, we take the AST from the parser and traverse it, replacing variables with values from the context and handling the various tag blocks. It is also home to some terrible terrible code, namely the <a href=https://github.com/Keats/tera/blob/fddb8a0b82cba7374bd0552fed1cf831b8943395/src/render.rs#L126-L241><code>eval_condition</code></a> method that checks <code>if</code> and <code>elif</code> conditions. It has a cyclomatic complexity of 27 apparently. It also contains the classic test fixing snippet that will be removed after I handle calculations properly:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=font-style:italic;color:#5c6773>// TODO: fix properly
</span><span style=font-style:italic;color:#5c6773>// TODO: add tests for float maths arithmetics
</span><span style=color:#ff7733>if</span><span> result</span><span style=color:#f29668>.</span><span style=color:#f07178>fract</span><span>() </span><span style=color:#f29668>< </span><span style=color:#f29718>0.01 </span><span>{
</span><span>    result </span><span style=color:#f29668>=</span><span> result</span><span style=color:#f29668>.</span><span style=color:#f07178>round</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><h2 id=feedback-on-the-dev-aspect>Feedback on the dev aspect</h2><p>The more Rust I do, the more I like it. There are times where you might look at the screen blankly for a few minutes and then decide to have a walk instead but it happens less and less. IRC and the <a href=https://www.reddit.com/r/rust>Rust subreddit</a> are very good source for help if you are stuck and they have interesting conversations.<p>With no hesitation, <a href=https://github.com/Manishearth/rust-clippy>Clippy</a> is the MVP of the development tools I'm using at the moment across all languages (Rust, Python and TypeScript mostly). It is a linter that catches lots of errors or bad code and shows you how to fix or how to do what you wanted to do but in a clearer way. The team is adding lints continuously so I usually just <code>cargo update</code> my projects every week or so just so I can run the latest <code>clippy</code> on it.<p>Error messages are usually very good and are getting <a href=https://github.com/rust-lang/rust/pull/32756>even better soon</a>.<h2 id=what-s-next>What's next</h2><p>The main things Tera are missing right now are filters and a way to add custom tag blocks. If anyone thinks that it is 2016 and therefore should use a parser combinator, feel free to submit a PR! I also welcome any feedback on Tera design as it doesn't have to be a clone of Jinja2 or Django.<p>Since I am quite busy with our first product <a href=https://github.com/wearewizards/proppyweb>Proppy</a>, I won't have a huge amount of time so any help is welcome.<p>To finish on a "Rust for web" note, the last main thing I would miss to try it for real is a validation crate that would work <a href=https://gist.github.com/Keats/32d26f699dcc13ebd41b>like this gist</a>. We use <a href=https://marshmallow.readthedocs.org/en/latest/>marshmallow</a> in proppy and it makes validation API data a breeze. Unfortunately, with compiler plugins being still unstable, I don't think I will start working on that. There is a RFC for stabilization though: <a href=https://github.com/rust-lang/rfcs/pull/1566>Procedural macros</a>.</section></article></main></div>