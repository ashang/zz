<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Writing my first Rust crate: jsonwebtoken
        
    </title><meta content="Writing my first Rust crate: jsonwebtoken" property=og:title><meta content="Experience writing a JWT library in Rust" property=og:description><meta content="Experience writing a JWT library in Rust" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://ashang.github.io/zz/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://ashang.github.io/zz/atom.xml rel=alternate title=atbb type=application/atom+xml><link href=https://ashang.github.io/zz/theme/light.css rel=stylesheet><link href=https://ashang.github.io/zz/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://ashang.github.io/zz/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://ashang.github.io/zz/>atbb</a><div class=socials><a class=social href=https://github.com/ashang/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=$BASE_URL/search/ style=margin-left:.7em>Search</a><a href=/notes style=margin-left:.7em>/notes</a><a href=/posts style=margin-left:.7em>/posts</a><a href=/gallery style=margin-left:.7em>/gallery</a><a href=/tags style=margin-left:.7em>/tags</a><a href=/projects style=margin-left:.7em>/projects</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://ashang.github.io/zz/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Writing my first Rust crate: jsonwebtoken<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2015-11-04</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#what-are-jwts>What are JWTs</a><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#enter-jsonwebtoken>Enter jsonwebtoken</a><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#thoughts>Thoughts</a> <ul><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#cargo>Cargo</a><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#error-handling>Error handling</a><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#testing-and-benchmark-support>Testing and benchmark support</a><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#to-owned>.to_owned()</a><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#community>Community</a></ul><li><a href=https://ashang.github.io/zz/posts/writing-my-first-crate/#conclusion>Conclusion</a></ul><section class=body><p>After <a href=https://ashang.github.io/zz/posts/writing-my-first-crate/2015-10-01_trying-rust-for-web-services.md>looking into Rust for webservices</a>, I concluded that, while it was not mature enough yet in my opinion, the language itself is quite nice and I would be interested in writing more of it. So here it is, my first crate (the name for packages in Rust): <a href=https://crates.io/crates/jsonwebtoken>jsonwebtoken</a> (code on <a href=https://github.com/keats/rust-jwt>github</a>).<h2 id=what-are-jwts>What are JWTs</h2><p>First of all a very quick introduction on JSON Web Token (JWT). If you already know about them you can skip this.<p>JWTs are a way to transmit data using JSON — hence the name — and are mostly used for APIs and token based authentication. You can read the standard <a href=http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html>there</a>.<p>Rather than having a session in a database, you would store some non-sensitive data in your token that allow you to identify the user.<p>Here's what a JWT looks like (with the fields shortened for example's sake):<pre class=language-js data-lang=js style=background:#0f1419;color:#bfbab0><code class=language-js data-lang=js><span style=font-style:italic;color:#5c6773>// header.payload.signature
</span><span>eyJhbGciOiJIUzI1Ni</span><span style=color:#f29668>.</span><span>eyJzdWIiOiIxMjM0NTY3ODkwIn0</span><span style=color:#f29668>.</span><span>Rq8IxqeX7eA6GgYxlcHdP
</span></code></pre><p>From the code above, you can see that a JWT has 3 parts, separated by a <code>.</code>. All of those parts are base64 encoded, which means it is trivial to decode (remember the non-sensitive data point above?).<p>The first is the header, that typically contains the following:<pre class=language-js data-lang=js style=background:#0f1419;color:#bfbab0><code class=language-js data-lang=js><span>{
</span><span>  </span><span style=color:#c2d94c>"alg"</span><span>: </span><span style=color:#c2d94c>"HS256"</span><span style=color:#bfbab0cc>, </span><span style=font-style:italic;color:#5c6773>// which algorithm was used to sign
</span><span>  </span><span style=color:#c2d94c>"typ"</span><span>: </span><span style=color:#c2d94c>"JWT"  </span><span style=font-style:italic;color:#5c6773>// actually optional
</span><span>}
</span></code></pre><p>The second is the claims object, which contains an arbitrary JSON object. There are some reserved claim name such as <code>exp</code> for an expiration timestamp but none of them are mandatory. Typically in an app, you would store the user id along as some token metadata such as exp mentioned above for example.<p>The last part is the signature which is obtained the following way in pseudo-code:<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span>payload </span><span style=color:#f29668>= </span><span style=color:#ffb454>base64</span><span>(header) </span><span style=color:#f29668>+ </span><span style=color:#c2d94c>"." </span><span style=color:#f29668>+ </span><span style=color:#ffb454>base64</span><span>(claims)
</span><span style=color:#f29668>// </span><span style=color:#c2d94c>"secret" </span><span style=color:#f29668>is </span><span>your secret private key
</span><span>signature </span><span style=color:#f29668>= </span><span style=color:#ffb454>Hmac</span><span>(payload</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"secret"</span><span style=color:#bfbab0cc>, </span><span>Sha256)
</span></code></pre><p>As you can see it's quite a convenient way to transfer some data and the signature ensures that the payload was not tampered with (there are some issues though, such as <a href=https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/>this vulnerability</a>).<h2 id=enter-jsonwebtoken>Enter jsonwebtoken</h2><p>I was implementing JWT in a Go project using the <a href=https://github.com/dgrijalva/jwt-go>jwt-go</a> library when I realised a JWT library was something simple enough that I could try in Rust.<p>We can see there are already <a href="https://crates.io/search?q=jwt">crates</a> for that available but <a href=https://github.com/GildedHonour/frank_jwt>one</a> only allows string types and the other put too much important on the registered claims to my liking.<p>I didn't implement the standard to the letter as I wanted to keep it simple for now and not support some part of it (having <code>none</code> a valid value for the alg header makes no sense to me therefore is not supported).<p>Compared to the Go library (which is quite good!), using Rust allows leveraging generics to have type-safe claims. For example, the claims in jwt-go are stored in a <code>map[string]interface{}</code> which is the only way to do so and therefore need type assertion when decoding claims to access its true type. The next version (v3 at the time of writing) seem to allow passing a struct though.<p>Here's how jsonwebtoken is used in practice, taken from the example in the crate:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>extern crate</span><span> jsonwebtoken </span><span style=color:#f29668>as</span><span> jwt</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>extern crate</span><span> rustc_serialize</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=color:#ff7733>use </span><span>jwt</span><span style=color:#f29668>::</span><span>{
</span><span>    Algorithm</span><span style=color:#bfbab0cc>,
</span><span>    encode</span><span style=color:#bfbab0cc>,
</span><span>    decode
</span><span>}</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=font-style:italic;color:#5c6773>// Deriving RustcEncodable and RustcDecodable make Claims satisfy the jwt::Part trait
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Debug</span><span style=color:#bfbab0cc>,</span><span> RustcEncodable</span><span style=color:#bfbab0cc>,</span><span> RustcDecodable)]
</span><span style=color:#ff7733>struct </span><span style=color:#59c2ff>Claims </span><span>{
</span><span>    sub</span><span style=color:#bfbab0cc>:</span><span> String,
</span><span>    company</span><span style=color:#bfbab0cc>:</span><span> String
</span><span>}
</span><span>
</span><span style=color:#ff7733>fn </span><span style=color:#ffb454>main</span><span>() {
</span><span>    </span><span style=color:#ff7733>let</span><span> my_claims </span><span style=color:#f29668>=</span><span> Claims {
</span><span>        sub</span><span style=color:#bfbab0cc>: </span><span style=color:#c2d94c>"b@b.com"</span><span style=color:#f29668>.</span><span style=color:#f07178>to_owned</span><span>()</span><span style=color:#bfbab0cc>,
</span><span>        company</span><span style=color:#bfbab0cc>: </span><span style=color:#c2d94c>"ACME"</span><span style=color:#f29668>.</span><span style=color:#f07178>to_owned</span><span>()
</span><span>    }</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>let</span><span> key </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"secret"</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=color:#ff7733>let</span><span> token </span><span style=color:#f29668>= </span><span style=color:#ff7733>match </span><span>encode</span><span style=color:#f29668>::</span><span>&LTClaims>(my_claims</span><span style=color:#bfbab0cc>,</span><span> key</span><span style=color:#f29668>.</span><span style=color:#f07178>to_owned</span><span>()</span><span style=color:#bfbab0cc>, </span><span>Algorithm</span><span style=color:#f29668>::</span><span style=color:#f29718>HS256</span><span>) {
</span><span>        </span><span style=font-style:italic;color:#39bae6>Ok</span><span>(t) </span><span style=color:#f29668>=></span><span> t</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=font-style:italic;color:#39bae6>Err</span><span>(</span><span style=color:#f29668>_</span><span>) </span><span style=color:#f29668>=> </span><span style=color:#f07178>panic!</span><span>()
</span><span>    }</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#5c6773>// or let token = try!(encode::&LTClaims>(my_claims, key.to_owned(), Algorithm::HS256));
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>// And then decode it back into a Claims object
</span><span>    </span><span style=color:#ff7733>let</span><span> claims </span><span style=color:#f29668>= </span><span style=color:#ff7733>match </span><span>decode</span><span style=color:#f29668>::</span><span>&LTClaims>(token</span><span style=color:#f29668>.</span><span style=color:#f07178>to_owned</span><span>()</span><span style=color:#bfbab0cc>,</span><span> key</span><span style=color:#f29668>.</span><span style=color:#f07178>to_owned</span><span>()</span><span style=color:#bfbab0cc>, </span><span>Algorithm</span><span style=color:#f29668>::</span><span style=color:#f29718>HS256</span><span>) {
</span><span>        </span><span style=font-style:italic;color:#39bae6>Ok</span><span>(c) </span><span style=color:#f29668>=></span><span> c</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=font-style:italic;color:#39bae6>Err</span><span>(err) </span><span style=color:#f29668>=> </span><span style=color:#ff7733>match</span><span> err {
</span><span>            Error</span><span style=color:#f29668>::</span><span>InvalidToken </span><span style=color:#f29668>=> </span><span style=color:#f07178>panic!</span><span>()</span><span style=color:#bfbab0cc>, </span><span style=font-style:italic;color:#5c6773>// Example on how to handle a specific error
</span><span>            </span><span style=color:#f29668>_ => </span><span style=color:#f07178>panic!</span><span>()
</span><span>        }
</span><span>    }</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#5c6773>// or let claims = try!(decode::&LTClaims>(token.to_owned(), key.to_owned(), Algorithm::HS256));
</span><span>}
</span></code></pre><p>On the other hand, decoding the token gives you an instance of the <code>Claims</code> struct declared in the function and thanks to the <code>Result</code> type, we are certain that if we are in the <code>Ok()</code> branch, the variable contains valid data.<p>How cool is that? And we can use any struct we want as long as the struct we use satisfy the <a href=https://github.com/Keats/rust-jwt/blob/6ae77c0b068328c47febe4169d6d28c0c66ba101/src/lib.rs#L29-L47><code>Part</code> trait</a>, which is done automatically by deriving <code>RustcEncodable</code> and <code>RustcDecodable</code>. I'm guessing other languages with generics implement similar things for their JWT libraries but it feels cleaner to me compared to the current version of the Go one.<h2 id=thoughts>Thoughts</h2><p>Here are some thoughts on the process of creating that crate.<h3 id=cargo>Cargo</h3><p>Cargo is really cool. It probably is the smoothest package manager of all the programming languages that I've tried. From installing crates to publishing the package on <a href=https://crates.io/>crates.io</a>, everything works.<p>I think the main thing missing for me is built-in vendoring, to not be dependent on a third party (crates.io).<h3 id=error-handling>Error handling</h3><p>One of the most annoying thing for me in Go is all those <code>if err != nil</code>. After trying Rust, I wish there was an equivalent of the <code>try!</code> macro so I could get rid of all that code cluttering my functions.<p>The <code>Result</code> type makes error checking mandatory to handle them, like in the example above. Pattern matching also has to be exhaustive, meaning that every possible value of the type I am matching has to be handled, from numbers to enum members and errors.<h3 id=testing-and-benchmark-support>Testing and benchmark support</h3><p>Having tests built-in the language and the package manager is very nice, ensuring there is no barrier to tests.<p>It is missing an easy setup and teardown method though but I think I have seen macros for that and, hopefully, someone will make a tool similar to the amazing <a href=https://github.com/smartystreets/goconvey>goconvey</a>.<h3 id=to-owned>.to_owned()</h3><p>If you look at that the code, it is littered with to_owned() calls which converts a string literal (<code>&str</code>) into a <code>String</code>.<p>I wish there was a quickway to create a <code>String</code> (maybe there is but I haven't found it yet other than writing a macro) such as typing a string into backtick for example:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let</span><span> secret </span><span style=color:#f29668>=</span><span> `secret`</span><span style=color:#bfbab0cc>;
</span></code></pre><p>Probably a silly idea but it would make things like tests less noisy.<h3 id=community>Community</h3><p>The IRC channels (<code>#rust</code> and <code>#rust-beginners</code> on <code>irc.mozilla.org</code>) and the <a href=https://www.reddit.com/r/rust>rust subreddit</a> were very helpful.<h2 id=conclusion>Conclusion</h2><p>That was quite a pleasant experience!<p>While I'm still very much a complete newbie in Rust, I'm looking forward to making another library in Rust. It will probably some kind of port of <a href=https://github.com/mattes/migrate>migrate</a>, ie a tool to handle SQL migrations. If you have any comments or find a bug, feel free to open an issue or submit a pull request to <a href=https://github.com/keats/rust-jwt>the repo</a>.<p>Lastly, thanks to the <a href=https://github.com/jpadilla/pyjwt>pyjwt library</a> for the API inspiration!</section></article></main></div>