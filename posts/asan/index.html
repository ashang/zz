<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         asan
        
    </title><meta content=asan property=og:title><meta content="An elegant and understated" property=og:description><meta content="An elegant and understated" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://ashang.github.io/zz/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://ashang.github.io/zz/atom.xml rel=alternate title=atbb type=application/atom+xml><link href=https://ashang.github.io/zz/theme/light.css rel=stylesheet><link href=https://ashang.github.io/zz/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://ashang.github.io/zz/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://ashang.github.io/zz/>atbb</a><div class=socials><a class=social href=https://github.com/ashang/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=$BASE_URL/search/ style=margin-left:.7em>Search</a><a href=/notes style=margin-left:.7em>/notes</a><a href=/posts style=margin-left:.7em>/posts</a><a href=/gallery style=margin-left:.7em>/gallery</a><a href=/tags style=margin-left:.7em>/tags</a><a href=/projects style=margin-left:.7em>/projects</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://ashang.github.io/zz/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>asan<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2018-07-18</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://ashang.github.io/zz/posts/asan/#addresssanitizer-is-a-fast-memory-error-detector-it-consists-of-a-compiler-instrumentation-module-and-a-run-time-library-the-tool-can-detect-the-following-types-of-bugs>AddressSanitizer is a fast memory error detector. It consists of a compiler instrumentation module and a run-time library. The tool can detect the following types of bugs:</a><li><a href=https://ashang.github.io/zz/posts/asan/#asan>ASan</a><li><a href=https://ashang.github.io/zz/posts/asan/#deallocation-of-nonallocated-memory>Deallocation of Nonallocated Memory</a><li><a href=https://ashang.github.io/zz/posts/asan/#how-asan-works>How ASan Works</a><li><a href=https://ashang.github.io/zz/posts/asan/#performance-impact>Performance Impact</a><li><a href=https://ashang.github.io/zz/posts/asan/#limitations>Limitations</a><li><a href=https://ashang.github.io/zz/posts/asan/#overflow-of-c-containers>Overflow of C++ Containers</a><li><a href=https://ashang.github.io/zz/posts/asan/#siblings>Siblings:</a><li><a href=https://ashang.github.io/zz/posts/asan/#heap-use-after-free>heap use after free</a><li><a href=https://ashang.github.io/zz/posts/asan/#asan-report-example-heap-use-after-free>ASan report example: heap-use-after-free</a><li><a href=https://ashang.github.io/zz/posts/asan/#leaksanitizer-asan-s-leak-detector>LeakSanitizer (ASan’s leak detector)</a><li><a href=https://ashang.github.io/zz/posts/asan/#asan-report-example-stack-use-after-scope>ASan report example: stack-use-after-scope</a><li><a href=https://ashang.github.io/zz/posts/asan/#asan-report-example-stack-use-after-return>ASan report example: stack-use-after-return</a><li><a href=https://ashang.github.io/zz/posts/asan/#asan-report-example-memory-leak>ASan report example: memory leak</a><li><a href=https://ashang.github.io/zz/posts/asan/#cat-tests-use-after-free-c>cat tests/use-after-free.c</a><li><a href=https://ashang.github.io/zz/posts/asan/#qa>QA</a><li><a href=https://ashang.github.io/zz/posts/asan/#https-github-com-google-sanitizers-wiki-addresssanitizercomparisonofmemorytools>https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools</a><li><a href=https://ashang.github.io/zz/posts/asan/#memorysanitizer-msan-is-a-detector-of-uninitialized-memory-reads-in-c-c-programs>MemorySanitizer (MSan) is a detector of uninitialized memory reads in C/C++ programs.</a> <ul><li><a href=https://ashang.github.io/zz/posts/asan/#getting-memorysanitizer>Getting MemorySanitizer</a><li><a href=https://ashang.github.io/zz/posts/asan/#using-memorysanitizer>Using MemorySanitizer</a></ul></ul><section class=body><h1 id=addresssanitizer-is-a-fast-memory-error-detector-it-consists-of-a-compiler-instrumentation-module-and-a-run-time-library-the-tool-can-detect-the-following-types-of-bugs>AddressSanitizer is a fast memory error detector. It consists of a compiler instrumentation module and a run-time library. The tool can detect the following types of bugs:</h1><p>Out-of-bounds accesses to heap, stack and globals Use-after-free Use-after-return (to some extent) Double-free, invalid free Typical slowdown introduced by AddressSanitizer is 2x. How to build Follow the clang build instructions. Note: CMake build does not work yet. See bug 12272. Usage Simply compile and link your program with -faddress-sanitizer flag. To get a reasonable performance add -O1 or higher. To get nicer stack traces in error messages add -fno-omit-frame-pointer. To get perfect stack traces you may need to disable inlining (just use -O1) and tail call elimination (-fno-optimize-sibling-calls). % cat example_UseAfterFree.cc int main(int argc, char **argv) { int *array = new int[100]; delete [] array; return array[argc]; // BOOM } % clang -O1 -g -faddress-sanitizer -fno-omit-frame-pointer example_UseAfterFree.cc If a bug is detected, the program will print an error message to stderr and exit with a non-zero exit code. Currently, AddressSanitizer does not symbolize its output, so you may need to use a separate script to symbolize the result offline (this will be fixed in future). % ./a.out 2> log % projects/compiler-rt/lib/asan/scripts/asan_symbolize.py / < log | c++filt ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8 READ of size 4 at 0x7f7ddab8c084 thread T0 #0 0x403c8c in main example_UseAfterFree.cc:4 #1 0x7f7ddabcac4d in __libc_start_main ??:0 0x7f7ddab8c084 is located 4 bytes inside of 400-byte region [0x7f7ddab8c080,0x7f7ddab8c210) freed by thread T0 here: #0 0x404704 in operator delete<a href=https://ashang.github.io/zz/posts/asan/void*></a> ??:0 #1 0x403c53 in main example_UseAfterFree.cc:4 #2 0x7f7ddabcac4d in __libc_start_main ??:0 previously allocated by thread T0 here: #0 0x404544 in operator new[](unsigned long) ??:0 #1 0x403c43 in main example_UseAfterFree.cc:2 #2 0x7f7ddabcac4d in __libc_start_main ??:0 ==9442== ABORTING __has_feature(address_sanitizer) In some cases one may need to execute different code depending on whether AddressSanitizer is enabled. __has_feature can be used for this purpose. #if defined(__has_feature) && __has_feature(address_sanitizer) code that runs only under AddressSanitizer #else code that does not run under AddressSanitizer #endif Supported Platforms AddressSanitizer is supported on Linux x86_64 (tested on Ubuntu 10.04). MacOS 10.6 i386/x86_64. Support for Linux i386/ARM and MacOS 10.7 is in progress (it may work, but is not guaranteed too).<h1 id=asan>ASan</h1><p>● Dynamic testing tool, finds memory bugs ○ Buffer overflows, use-after-free Compiler instrumentation + run-time library<p>● Every 8 bytes of application memory are associated with 1 byte of “shadow” memory ● Redzones are created around buffers; freed memory is put into quarantine ● Shadow of redzones and freed memory is “poisoned” ● On every memory access compiler-injected code checks if shadow is poisoned<pre style=background:#0f1419;color:#bfbab0><code><span>    '-fsanitize=address -lasan',
</span><span>    '-fsanitize=cfi',
</span><span>    '-fsanitize=integer',
</span><span>    '-fsanitize=memory',
</span><span>    '-fsanitize=thread',
</span><span>    '-fsanitize=undefined',
</span></code></pre><pre style=background:#0f1419;color:#bfbab0><code><span>    CPPFLAGS = $(AC_CPPFLAGS) -fsanitize=address -fno-stack-protector -fno-omit-frame-pointer -fno-var-tracking
</span></code></pre><pre style=background:#0f1419;color:#bfbab0><code><span>// clang -fsanitize=address a.c -O -c  && nm a.o | grep asan_stack_malloc
</span><span>// clang -fsanitize=address a.c -O -c -mllvm -asan-stack=0 && nm a.o | grep asan_stack_malloc
</span><span>
</span><span>int foo(int a, int b) {
</span><span>  int x[10];
</span><span>  x[b] = 1;
</span><span>  return x[a];
</span><span>}
</span></code></pre><pre style=background:#0f1419;color:#bfbab0><code><span>#include &LTstdio.h>
</span><span>
</span><span>void print(int *pBuf, int size) {
</span><span>    for (int i = 0; i < size; ++i) {
</span><span>        printf("%d ", pBuf[i]);
</span><span>    }
</span><span>    printf("\n");
</span><span>}
</span><span>
</span><span>//set -x
</span><span>//#PASS
</span><span>//clang++ -shared -fPIC libtest.cpp -o libtest.so
</span><span>//#PASS
</span><span>//clang++ -shared -fPIC libtest.cpp -o libtest.so -fsanitize=address
</span><span>//#FAIL
</span><span>//clang++ -shared -fPIC libtest.cpp -o libtest.so -fsanitize=address -Wl,--no-undefined
</span><span>//
</span><span>//#PASS
</span><span>//g++ -shared -fPIC libtest.cpp -o libtest.so
</span><span>//#PASS
</span><span>//g++ -shared -fPIC libtest.cpp -o libtest.so -fsanitize=address
</span><span>//#FAIL
</span><span>//g++ -shared -fPIC libtest.cpp -o libtest.so -fsanitize=address -Wl,--no-undefined
</span><span>//
</span><span>//#PASS
</span><span>//clang++ -shared -fPIC libtest.cpp -o libtest.so -Wl,--no-undefined
</span><span>//#PASS
</span><span>//g++ -shared -fPIC libtest.cpp -o libtest.so -Wl,--no-undefined
</span><span>
</span></code></pre><h1 id=deallocation-of-nonallocated-memory>Deallocation of Nonallocated Memory</h1><p>Attempting to deallocate nonallocated memory can result in a crash.<p>In the following example, the value variable is allocated on the stack and deallocated when the function exits, therefore calling free on it is incorrect.<pre style=background:#0f1419;color:#bfbab0><code><span>int value = 42;
</span><span>free(&value); // Error: free called on stack allocated variable
</span></code></pre><h1 id=how-asan-works>How ASan Works</h1><p>The Address Sanitizer replaces the malloc and free functions with custom implementations that allow regions surrounding the requested memory to be checked for invalid access.<p>When the malloc function is called, it allocates the requested amount of memory and marks the surrounding regions as off-limits. When the free function is called, it marks the region as off-limits and adds it to a quarantine queue, which delays when that memory can be reused by the malloc function. All memory accesses in the code are transformed by the compiler according to Listing 1.<pre style=background:#0f1419;color:#bfbab0><code><span>// Before
</span><span>*address = ...;  // or: ... = *address;
</span><span>
</span><span>// After
</span><span>if (IsMarkedAsOffLimits(address)) {
</span><span>  ReportError(address);
</span><span>}
</span><span>*address = ...;  // or: ... = *address;
</span></code></pre><p>When code is run with ASan enabled, any access to a memory region that's off-limits results in an error reported by the Address Sanitizer.<h1 id=performance-impact>Performance Impact</h1><p>Running your code with Address Sanitizer checks enabled typically results in CPU slowdown of 2⨉ to 5⨉, and an increase in memory usage by 2⨉ to 3⨉. You can improve memory utilization by compiling at the -O1 optimization level.<p>For most use cases, the overhead introduced by the Address Sanitizer should be acceptable for daily use during development—in fact, you may not even notice any slowdown.<p>https://llvm.org/devmtg/2013-11/slides/Serebryany-ASAN.pdf ● ~2x slowdown<ul><li>https://developer.apple.com/documentation/code_diagnostics/address_sanitizer/</ul><h1 id=limitations>Limitations</h1><p>AddressSanitizer uses more real memory than a native run. How much -- depends on the allocations sizes. The smaller the allocations you make the bigger the overhead. On 64-bit platforms AddressSanitizer maps (but not reserves) 16+ Terabytes of virtual address space. This means that tools like ulimit may not work as usually expected. Static linking is not supported.<p>As a runtime diagnostic, the Address Sanitizer can only detect memory errors that are encountered during program execution. To exercise the full extent of your code, incorporate comprehensive unit tests.<p>The Address Sanitizer cannot detect memory leaks, access to uninitialized memory, or integer overflow. However, you can use ASan in addition to TSan, UBSan, and Instruments to find additional issues.<p>Sanitization is performed on heap and stack buffers as well as on global variables. Buffer overflow and underflow can result in a crash or other unpredictable behavior.<p>Global, Heap, and Stack Overflows in C In the following example, the global_array, heap_buffer, and stack_buffer variables each have valid indexes in the range [0, 9], but are accessed at index 10, causing an overflow.<pre style=background:#0f1419;color:#bfbab0><code><span>int global_array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
</span><span>void foo() {
</span><span>    int idx = 10;
</span><span>    global_array[idx] = 42; // Error: out of bounds access of global variable
</span><span>    char *heap_buffer = malloc(10);
</span><span>    heap_buffer[idx] = 'x'; // Error: out of bounds access of heap allocated variable
</span><span>    char stack_buffer[10];
</span><span>    stack_buffer[idx] = 'x'; // Error: out of bounds access of stack allocated variable
</span><span>}
</span></code></pre><p>Add a bounds check before attempting to access a buffer at an index.<h1 id=overflow-of-c-containers>Overflow of C++ Containers</h1><p>This check detects when a libc++ container is accessed beyond the region [container.begin(), container.end()) — even when the accessed memory is in a heap-allocated buffer used internally by a container.<p>This check is disabled by default, because it requires that all statically linked libraries using std::vector are built with Address Sanitizer enabled.<pre style=background:#0f1419;color:#bfbab0><code><span>std::vector&LTint> vector;vector.push_back(0);vector.push_back(1);vector.push_back(2);
</span><span>auto *pointer = &vector[0];
</span><span>return pointer[3]; // Error: out of bounds access for vector
</span></code></pre><h1 id=siblings>Siblings:</h1><ul><li><p>ThreadSanitizer (TSan): data races</p><li><p>MemorySanitizer (MSan): uses of uninitialized memory</p><li><p>ASan: stack unwinding with frame pointers</p><li><p>TSan: catching synchronization via atomics</p><li><p>MSan: avoid false positives</p></ul><p>vim中搜索能不带括号？<h1 id=heap-use-after-free>heap use after free</h1><p>When you have multiple copies of the same pointer, e.g.<p>int *p1 = malloc(sizeof (int)); int *p2 = p1; int *p3 = p2; then freeing any of them invalidates all of them:<p>free(p2); // Now p1, p2, p3 have invalid values. // The C standard calls these "indeterminate values"; accessing them has undefined behavior You can manually set p2 to NULL after freeing, but that still leaves p1 and p3 dangling. You cannot automatically find all copies of a pointer value that may exist anywhere in your program's memory.<h1 id=asan-report-example-heap-use-after-free>ASan report example: heap-use-after-free</h1><p>int main(int argc, char **argv) { int *array = new int[100]; delete [] array; return array[argc]; // BOOM }<pre style=background:#0f1419;color:#bfbab0><code><span>clang++ -O1 -g -fsanitize=address a.cc
</span></code></pre><h1 id=leaksanitizer-asan-s-leak-detector>LeakSanitizer (ASan’s leak detector)</h1><ul><li>Similar to other tools: tcmalloc, valgrind, etc<li>Faster than any of those ○ No extra overhead on top of ASan at run-time ○ Small overhead at shutdown<li>Based on the ASan/MSan/TSan allocator<li>Can be bundled with ASan/MSan/TSan or used as a standalone tool ○ Currently, supported only in ASan or standalone<li>Requires StopTheWorld() -- today Linux only</ul><p>[1] ASAN_OPTIONS=check_initialization_order=true [2] ASAN_OPTIONS=strict_init_order=true (has false positives).<h1 id=asan-report-example-stack-use-after-scope>ASan report example: stack-use-after-scope</h1><p>int main() { int *p; { int x = 0; p = &x; } return *p; } % clang -g -fsanitize=address,use-after-scope a.cc ; ./a. out ==15839==ERROR: AddressSanitizer: stack-use-after-scope READ of size 4 at 0x7fffe06c20a0 thread T0 #0 0x46103d in main a.cc:4 Address is located in stack of thread T0 at offset 160 in frame #0 0x460daf in main a.cc:1 This frame has 4 object(s): [96, 104) 'p' [160, 164) 'x' <== Memory access at offset 160 is inside this variable<h1 id=asan-report-example-stack-use-after-return>ASan report example: stack-use-after-return</h1><p>int *g; void LeakLocal() { int local; g = &local; }<p>int main() { LeakLocal(); return *g; }<p>% clang -g -fsanitize=address a.cc % ASAN_OPTIONS=detect_stack_use_after_return=1 ./a.out ==19177==ERROR: AddressSanitizer: stack-use-after-return READ of size 4 at 0x7f473d0000a0 thread T0 #0 0x461ccf in main a.cc:8 Address is located in stack of thread T0 at offset 32 in frame #0 0x461a5f in LeakLocal() a.cc:2 This frame has 1 object(s): [32, 36) 'local' <== Memory access at offset 32<h1 id=asan-report-example-memory-leak>ASan report example: memory leak</h1><p>int *g = new int; int main() { g = 0; // Lost the pointer. }<p>% clang -g -fsanitize=address a.cc % ASAN_OPTIONS=detect_leaks=1 ./a.out ==19894==ERROR: AddressSanitizer: detected memory leaks Direct leak of 4 byte(s) in 1 object(s) allocated from: #0 0x44a3b1 in operator new(unsigned long) #1 0x414f66 in __cxx_global_var_init leak.cc:<h1 id=cat-tests-use-after-free-c>cat tests/use-after-free.c</h1><p>#include &LTstdlib.h> int main() { char <em>x = (char</em>)malloc(10 * sizeof(char*)); free(x); return x[5]; } % ../clang_build_Linux/Release+Asserts/bin/clang -fsanitize=address -O1 -fno-omit-frame-pointer -g tests/use-after-free.c Now, run the<h1 id=qa>QA</h1><p>Q: Can AddressSanitizer continue running after reporting first error?<p>A: Yes it can, AddressSanitizer has recently got continue-after-error mode. This is somewhat experimental so may not yet be as reliable as default setting (and not as timely supported). Also keep in mind that errors after the first one may actually be spurious. To enable continue-after-error, compile with -fsanitize-recover=address and then run your code with ASAN_OPTIONS=halt_on_error=0.<p>Q: Why didn't ASan report an obviously invalid memory access in my code?<p>A1: If your errors is too obvious, compiler might have already optimized it out by the time Asan runs.<p>A2: Another, C-only option is accesses to global common symbols which are not protected by Asan (you can use -fno-common to disable generation of common symbols and hopefully detect more bugs).<p>A3: If _FORTIFY_SOURCE is enabled, ASan may have false positives, see next question.<p>Q: I've compiled my code with -D_FORTIFY_SOURCE flag and ASan, or -D_FORTIFY_SOURCE is enabled by default in my distribution (most modern distributions). Now ASan misbehaves (either produces false warnings, or does not find some bugs).<p>A: Currently ASan (and other sanitizers) doesn't support source fortification, see https://github.com/google/sanitizers/issues/247. The fix should most likely be on the glibc side, see the (stalled) discussion here.<p>Q: When I link my shared library with -fsanitize=address, it fails due to some undefined ASan symbols (e.g. asan_init_v4)?<p>A: Most probably you link with -Wl,-z,defs or -Wl,--no-undefined. These flags don't work with ASan unless you also use -shared-libasan (which is the default mode for GCC, but not for Clang).<p>Q: My malloc stacktraces are too short or do not make sense?<p>A: Try to compile your code with -fno-omit-frame-pointer or set ASAN_OPTIONS=fast_unwind_on_malloc=0 (the latter would be a performance killer though unless you also specify malloc_context_size=2 or lower). Note that frame-pointer-based unwinding does not work on Thumb.<p>Q: My new() and delete() stacktraces are too short or do not make sense?<p>A: This may happen when the C++ standard library is linked statically. Prebuilt libstdc++/libc++ often do not use frame pointers, and it breaks fast (frame-pointer-based) unwinding. Either switch to the shared library with the -shared-libstdc++ flag, or use ASAN_OPTIONS=fast_unwind_on_malloc=0. The latter could be very slow.<p>Q: I'm using dynamic ASan runtime and my program crashes at start with "Shadow memory range interleaves with an existing memory mapping. ASan cannot proceed correctly.".<p>A1: If you are using shared ASan DSO, try LD_PRELOAD'ing Asan runtime into your program.<p>A2: Otherwise you are probably hitting a known limitation of dynamic runtime. Libasan is initialized at the end of program startup so if some preceeding library initializer did lots of memory allocations memory region required for ASan shadow memory could be occupied by unrelated mappings.<p>Q: The PC printed in ASan stack traces is consistently off by 1?<p>A: This is not a bug but rather a design choice. It is hard to compute exact size of preceding instruction on CISC platforms. So ASan just decrements 1 which is enough for tools like addr2line or readelf to symbolize addresses.<p>Q: I've ran with ASAN_OPTIONS=verbosity=1 and ASan tells something like<p>==30654== Parsed ASAN_OPTIONS: verbosity=1 ==30654== AddressSanitizer: failed to intercept 'memcpy' A: This warning is false (see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58680 for details).<p>Q: I've built my main executable with ASan. Do I also need to build shared libraries?<p>A: ASan will work even if you rebuild just part of your program. But you'll have to rebuild all components to detect all errors.<p>Q: I've built my shared library with ASan. Can I run it with unsanitized executable?<p>A: Yes! You'll need to build your library with dynamic version of ASan and then run executable with LD_PRELOAD=path/to/asan/runtime/lib.<p>Q: On Linux I am seeings a crash at startup with something like this<p>ERROR: AddressSanitizer failed to allocate 0x400000000 (17179869184) bytes at address 67fff8000 (errno: 12) A: Make sure you don't have 2 in /proc/sys/vm/overcommit_memory<p>Q: I'm working on a project that uses bare-metal OS with no pthread (TLS) support and no POSIX syscalls and want to use ASan, but its code depends on some stuff (e.g. dlsym) that is unavailable on my platform. Does ASan support bare-metal targets?<p>A: Out of the box we don't have support for your use case. The easiest for you would be to rip off everything you don't have and rebuild the ASan run-time. However, there have been many attempts in applying ASan to bare-metal and at least some were successful. E.g. http://events.linuxfoundation.org/sites/events/files/slides/Alexander_Popov-KASan_in_a_Bare-Metal_Hypervisor_0.pdf and also grep for "bare-metal" and similar stuff in https://groups.google.com/forum/#!forum/address-sanitizer group.<p>Q: Can I run AddressSanitizer with more aggressive diagnostics enabled?<p>A: Yes! In particular you may want to enable<p>CFLAGS += -fsanitize-address-use-after-scope ASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1:check_initialization_order=1:strict_init_order=1 check [Flags wiki] (https://github.com/google/sanitizers/wiki/AddressSanitizerFlags ) for more details on this.<p>Q: My library crashes with SIGABRT while calling free. What's going wrong?<p>A: Most probably you are dlopening your library with RTLD_DEEPBIND flag. ASan doesn't support RTLD_DEEPBIND, see issue #611 for details.<p>Q: I'm getting following error when building my code: gcc: error: cannot specify -static with -fsanitize=address.<p>A: ASan doesn't work with static linkage. You need to disable static linkage in order to use ASan on your code.<p>Q: What do 0xbebebebebebebebe and 0xbebebebe mean?<p>A: ASan, by default, writes 0xbe to newly allocated memory (see malloc_fill_byte). 0xbebebebebebebebe is (possibly) a 64-bit value that was allocated but not initialized. Similarly for 0xbebebebe.<p>Q: Can I mix code instrumented by Clang with code instrumented by GCC? Or can I at least compile code with Clang and link against GCC ASan runtime and vice versa?<p>A: No, you cannot, Clang and GCC have completely incompatible ASan implementations, you cannot mix them in any way.<h1 id=https-github-com-google-sanitizers-wiki-addresssanitizercomparisonofmemorytools>https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools</h1><p>DBI: dynamic binary instrumentation CTI: compile-time instrumentation UMR: uninitialized memory reads UAF: use-after-free (aka dangling pointer) UAR: use-after-return OOB: out-of-bounds x86: includes 32- and 64-bit. mudflap was removed in GCC 4.9, as it has been superseded by AddressSanitizer. Guard Page: a family of memory error detectors (Electric fence or DUMA on Linux, Page Heap on Windows, libgmalloc on OS X) gperftools: various performance tools/error detectors bundled with TCMalloc. Heap checker (leak detector) is only available on Linux. Debug allocator provides both guard pages and canary values for more precise detection of OOB writes, so it's better than guard page-only detectors.<h1 id=memorysanitizer-msan-is-a-detector-of-uninitialized-memory-reads-in-c-c-programs>MemorySanitizer (MSan) is a detector of uninitialized memory reads in C/C++ programs.</h1><p>Uninitialized values occur when stack- or heap-allocated memory is read before it is written. MSan detects cases where such values affect program execution.<p>MSan is bit-exact: it can track uninitialized bits in a bitfield. It will tolerate copying of uninitialized memory, and also simple logic and arithmetic operations with it. In general, MSan silently tracks the spread of uninitialized data in memory, and reports a warning when a code branch is taken (or not taken) depending on an uninitialized value.<p>MSan implements a subset of functionality found in Valgrind (Memcheck tool). It is significantly faster than Memcheck (TODO:benchmark).<h2 id=getting-memorysanitizer>Getting MemorySanitizer</h2><p>MemorySanitizer is part of LLVM trunk and has been widely available as a compile-time option in clang since version 4.0.<p>At this time, MSan supports x86_64, AArch64, PPC64, and MIPS64.<h2 id=using-memorysanitizer>Using MemorySanitizer</h2><p>To use MSan, compile and link your program with -fsanitize=memory -fPIE -pie.<p>To get any stack traces, add -fno-omit-frame-pointer.<p>% cat umr.cc #include &LTstdio.h><p>int main(int argc, char** argv) { int* a = new int[10]; a[5] = 0; if (a[argc]) printf("xx\n"); return 0; }<pre style=background:#0f1419;color:#bfbab0><code><span>clang -fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g -O2 umr.cc
</span><span>
</span><span>
</span><span>./a.out
</span><span>        ==6726==  WARNING: MemorySanitizer: UMR (uninitialized-memory-read)
</span><span>            #0 0x7fd1c2944171 in main umr.cc:6
</span><span>                #1 0x7fd1c1d4676c in __libc_start_main /build/buildd/eglibc-2.15/csu/libc-start.c:226
</span><span>                Origins tracking
</span><span>                MemorySanitizer can track back each uninitialized value to the memory allocation where it was created, and use this information in reports. This behaviour is enabled with the -fsanitize-memory-track-origins flag. It comes with additional 1.5x-2.5x slowdown, and makes the report from the previous example look like this:
</span><span>
</span><span>                %clang -fsanitize=memory -fsanitize-memory-track-origins -fPIE -pie -fno-omit-frame-pointer -g -O2 umr.cc
</span><span>                % ./a.out
</span><span>                ==6726==  WARNING: MemorySanitizer: UMR (uninitialized-memory-read)
</span><span>                    #0 0x7fd1c2944171 in main umr.cc:6
</span><span>                        #1 0x7fd1c1d4676c in __libc_start_main /build/buildd/eglibc-2.15/csu/libc-start.c:226
</span><span>                          ORIGIN: heap allocation:
</span><span>                              #0 0x7f5872b6a31b in operator new[](unsigned long) msan_new_delete.cc:39
</span><span>                                  #1 0x7f5872b62151 in main umr.cc:4
</span><span>                                      #2 0x7f5871f6476c in __libc_start_main /build/buildd/eglibc-2.15/csu/libc-start.c:226
</span><span>                                      Symbolization
</span><span>                                      Set MSAN_SYMBOLIZER_PATH environment variable to the path to llvm-symbolizer binary (normally built with LLVM), or just put llvm-symbolizer somewhere in your $PATH. MemorySanitizer will use it to symbolize reports on-the-fly.
</span></code></pre></section></article></main></div>